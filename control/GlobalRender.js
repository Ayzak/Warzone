/**
 *  Controler function will draw all the obects on the main canvas. 
 *
 *  singleton3
 *
 *  @Authors : Jeremy Locheron, Damien Cauquil.
 */

 /**
  *  Constructor
  *  @param string[canvas' ID], int[delay] delay for refresh
  */
var GlobalRender = function(canvasId, delay) {

    /* Behave as a Singleton's constructor. */
    if (arguments.callee._instance)
        return arguments.callee._instance;
    arguments.callee._instance = this;

    /* Retrieve the canvas. */
    this.canvas = document.getElementById(canvasId);

    /* Get 2D context. */
    this.context = this.canvas.getContext("2d");

    /* Save delay. */
    if (delay != null)
        this.delay = delay;
    else
        this.delay = 30;

    /* List of items to render. */
    this.items = [];

}

/**
 *  Add an item to the current GlobalRender
 *
 *  Handles every animated item (or not).
 *  @param object[item] to add on main stage.
 */
GlobalRender.prototype.add = function(item) {

    /* If item is not already in our list, add it. */
    if (this.items.indexOf(item) < 0)
        this.items.push(item);
}

/**
 *  Remove an item from managed items.
 *  @param object[item] to remove on main stage.
 */
GlobalRender.prototype.remove = function(item) {

    /* If item is already in our list, remove it. */
    if (this.items.indexOf(item) >= 0)
        this.items.splice(this.items.indexOf(item), 1);
}

/**
 *  Main loop.
 *
 *  This loop handles every item animation (next frame) and
 *  render the canvas generated by each item (returned by
 *  a call to render()) in the global canvas. Cooool.
 */
GlobalRender.prototype.loop = function() {
    window.requestAnimationFrame((function(me){
        return function() {
            me.animateItems();
        };
    })(this));

    setTimeout((function(t){
                return function(){
                    t.loop();
                };
            })(this), this.delay);
}

/**
 *  Function will place on the last plan few elements.
 *  @param object[item] to hide a part on the main stage.
 */
GlobalRender.prototype.moveToBack = function(item) {
    this.remove(item);
    this.items.unshift(item);
}

/**
 *  Function will place few elements on the firts plan on the canvas.
 *  @param object[item] to make one top on the main stage.
 */
GlobalRender.prototype.moveToFront = function(item) {
    this.remove(item);
    this.items.push(item);
}

/**
 *  Animate managed items.
 *
 *  Handles next frame callbacks and render each item
 *  inside the global canvas, given its position and size.
 *  You can apply a scale here by specifying a width/height
 *  different from the ones specified in your object constructor.
 */
GlobalRender.prototype.animateItems = function(){

    /* Clear global context. */
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

    /* For each registered item. */
    for (var i in this.items) {
        /* Ask item to generate next frame. */
        this.items[i].nextFrame();

        /* Render item frame inside the global context. */
        var item_canvas = this.items[i].render();
        try {
            this.context.drawImage(
                item_canvas,
                0,
                0,
                item_canvas.width,
                item_canvas.height,
                this.items[i].x,
                this.items[i].y,
                this.items[i].width,
                this.items[i].height );
        }
        catch(err) {
            console.log('bug !');
            console.log(this.items[i]);
            throw('oops');
            console.log(item_canvas.width+' '+item_canvas.height);
        }
    }
}

/**
 *  Function will compute new position for the responsive design.
 *  @param int[size] to compute new size for responsive design
 */
GlobalRender.prototype.onResize = function(width, height) {

    /* Set canvas width and height */
    this.canvas.style.width = width + 'px';
    this.canvas.style.height = height + 'px';
    this.canvas.width = width;
    this.canvas.height = height;

}
